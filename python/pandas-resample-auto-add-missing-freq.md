# pandas `resample()` 会自动添加缺失的 freq

`pd.resample()` 并不会直接忽略缺失的 freq，而是会为你自动添加缺失的部分。比如下面的例子，按照 `1H` resample，其实是缺失了 1 点的数据的，但是结果仍然会出现 1 点的结果：

```python
In [2]: import pandas as pd
   ...: 
   ...: # 创建一个 DataFrame，时间序列中间有缺失
   ...: data = {
   ...:     'value': [10, 20, 30]
   ...: }
   ...: index = pd.to_datetime([
   ...:     '2024-01-01 00:00:00',
   ...:     '2024-01-01 02:00:00',  # 注意：01:00 缺失
   ...:     '2024-01-01 03:00:00'
   ...: ])
   ...: df = pd.DataFrame(data, index=index)
   ...: 
   ...: print("原始数据：")
   ...: print(df)
   ...: 
   ...: # 使用 resample 以 1 小时为频率
   ...: resampled_df = df.resample('1H').count()
   ...: 
   ...: print("\n重采样后的数据（1H）：")
   ...: print(resampled_df)
原始数据：
                     value
2024-01-01 00:00:00     10
2024-01-01 02:00:00     20
2024-01-01 03:00:00     30

重采样后的数据（1H）：
                     value
2024-01-01 00:00:00      1
2024-01-01 01:00:00      0  # <-- 自动添加的 1 点的结果
2024-01-01 02:00:00      1
2024-01-01 03:00:00      1
```

所以如果你看到 resample count 的结果有 0，那就是 pandas 自己添加的，在此之前我一直没想通，为什么会出现 0。

但是还有一点需要注意，就是**自动添加的值**，在上面的例子我们看到自动添加的是 0，但是如果我们把 agg 方式换成 `mean`，结果就是 `NaN` 了：

```python
In [1]: import pandas as pd
   ...: 
   ...: # 创建一个 DataFrame，时间序列中间有缺失
   ...: data = {
   ...:     'value': [10, 20, 30]
   ...: }
   ...: index = pd.to_datetime([
   ...:     '2024-01-01 00:00:00',
   ...:     '2024-01-01 02:00:00',  # 注意：01:00 缺失
   ...:     '2024-01-01 03:00:00'
   ...: ])
   ...: df = pd.DataFrame(data, index=index)
   ...: 
   ...: print("原始数据：")
   ...: print(df)
   ...: 
   ...: # 使用 resample 以 1 小时为频率
   ...: resampled_df = df.resample('1H').mean()  # 这里换成 .mean()
   ...: 
   ...: print("\n重采样后的数据（1H）：")
   ...: print(resampled_df)
   ...: 
原始数据：
                     value
2024-01-01 00:00:00     10
2024-01-01 02:00:00     20
2024-01-01 03:00:00     30

重采样后的数据（1H）：
                     value
2024-01-01 00:00:00   10.0
2024-01-01 01:00:00    NaN  # <-- 现在是 NaN 了
2024-01-01 02:00:00   20.0
2024-01-01 03:00:00   30.0
```
